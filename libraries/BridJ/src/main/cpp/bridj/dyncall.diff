Index: dyncall/dynload/dynload_windows.c
===================================================================
--- dyncall/dynload/dynload_windows.c	(revision 1354)
+++ dyncall/dynload/dynload_windows.c	(working copy)
@@ -40,7 +40,9 @@
 DLLib* dlLoadLibrary(const char* libPath)
 {
   if (libPath != NULL) {
-    return (DLLib*) LoadLibraryA(libPath);
+    return (DLLib*) LoadLibraryW((wchar_t*)(void*)libPath);
+  	// http://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx
+    // return (DLLib*) LoadLibraryExA(libPath, NULL, LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR | LOAD_LIBRARY_DEFAULT_DIRS);
     /*return (DLLib*) LoadLibraryA(libPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);*/
   } else {
     return (DLLib*) GetModuleHandle(NULL);
Index: dyncall/dynload/dynload_syms_mach-o.c
===================================================================
--- dyncall/dynload/dynload_syms_mach-o.c	(revision 1354)
+++ dyncall/dynload/dynload_syms_mach-o.c	(working copy)
@@ -28,6 +28,7 @@
  dynamic symbol resolver for Mach-O
 
 */
+#include "../autovar/autovar_ARCH.h"
 
 #include "dynload.h"
 #include "dynload_alloc.h"
@@ -37,12 +38,19 @@
 #include <dlfcn.h>
 #include <string.h>
 
+#define DEBUG_SYMS 0
+#if DEBUG_SYMS
+#include <stdio.h>
+#endif
+
 #if defined(ARCH_X64)
 #define MACH_HEADER_TYPE mach_header_64
+#define MACH_MAGIC MH_MAGIC_64
 #define SEGMENT_COMMAND segment_command_64
 #define NLIST_TYPE nlist_64
 #else
 #define MACH_HEADER_TYPE mach_header
+#define MACH_MAGIC MH_MAGIC
 #define SEGMENT_COMMAND segment_command
 #define NLIST_TYPE nlist
 #endif
@@ -62,7 +70,18 @@
 	uint32_t symbolCount;
 };
 
-
+int isSameMacImageName(const char* libPath, const char* systemLibPath) {
+	if (!libPath || !systemLibPath)
+		return 0;
+	
+	if (!strcmp(libPath, systemLibPath))
+		return 1;
+	
+	if (strstr(libPath, "/libc.") && strstr(systemLibPath, "/libSystem."))
+		return 1;
+	
+	return 0;
+}
 DLSyms* dlSymsInit(const char* libPath) 
 {
 	DLSyms* pSyms = NULL;
@@ -70,23 +89,43 @@
 	for (iImage = 0, nImages = _dyld_image_count(); iImage < nImages; iImage++)
 	{
 		const char* name = _dyld_get_image_name(iImage);
-		if (name && !strcmp(name, libPath))
+		if (isSameMacImageName(libPath, name))
 		{
 			const struct MACH_HEADER_TYPE* pHeader = (const struct MACH_HEADER_TYPE*) _dyld_get_image_header(iImage);
 			const char* pBase = ((const char*)pHeader);
+			if (!pHeader)
+				return NULL;
+
+			if (pHeader->magic != MACH_MAGIC)
+				return NULL;
 			if (pHeader->filetype != MH_DYLIB)
 				return NULL;
-			if (pHeader->flags & MH_SPLIT_SEGS)
+			if (pHeader->flags & MH_SPLIT_SEGS || !(pHeader->flags & MH_DYLDLINK))
 				return NULL;
-
-			if (pHeader)
+			
 			{
 				uint32_t iCmd, nCmds = pHeader->ncmds;
 				const struct load_command* cmd = (const struct load_command*)(pBase + sizeof(struct MACH_HEADER_TYPE));
 				
 				for (iCmd = 0; iCmd < nCmds; iCmd++) 
 				{
-					if (cmd->cmd == LC_SYMTAB) 
+					#if DEBUG_SYMS
+					if (cmd->cmd == LC_DYLD_INFO_ONLY) {
+                        //const struct dyld_info_command* dcmd = (const struct dyld_info_command*)cmd;
+                        //const char* trie = dcmd = (pBase + dcmd->export_off);
+                        printf("Found unhandled (10.6+) LC_DYLD_INFO_ONLY command in '%s'\n", libPath);
+                        //uleb128 v = *(uleb128*)trie;
+                        
+                        return NULL;
+                    }
+                    #endif
+
+                    if (cmd->cmd & LC_REQ_DYLD) {
+                    	//printf("Found unhandled command in '%s' : %d\n", libPath, (int)cmd->cmd);
+                    	return NULL; // "unknown load command required for execution";
+                    }
+                    
+                    if (cmd->cmd == LC_SYMTAB) 
 					{
 						const struct symtab_command* scmd = (const struct symtab_command*)cmd;
 					
@@ -100,7 +139,6 @@
 					cmd = (const struct load_command*)(((char*)cmd) + cmd->cmdsize);
 				}
 			}
-			break;
 		}
 	}
 	return NULL;
@@ -132,6 +170,11 @@
 	if (nl->n_un.n_strx <= 1)
 		return NULL; // would be empty string anyway
 	
+    if (!(nl->n_type & N_EXT) || (nl->n_type & N_PEXT))
+        return NULL; // not a public external symbol
+    if (nl->n_type & N_STAB)
+        return NULL;
+    
 	//TODO skip more symbols based on nl->n_desc and nl->n_type ?
 	return nl;
 }
Index: dyncall/dynload/dynload_unix.c
===================================================================
--- dyncall/dynload/dynload_unix.c	(revision 1354)
+++ dyncall/dynload/dynload_unix.c	(working copy)
@@ -40,7 +40,7 @@
 
 DLLib* dlLoadLibrary(const char* libPath)
 {
-  return (DLLib*)dlopen(libPath,RTLD_NOW|RTLD_GLOBAL);
+  return (DLLib*)dlopen(libPath,RTLD_LAZY|RTLD_GLOBAL);
 }
 
 
Index: dyncall/buildsys/gmake/os/darwin.gmake
===================================================================
--- dyncall/buildsys/gmake/os/darwin.gmake	(revision 1354)
+++ dyncall/buildsys/gmake/os/darwin.gmake	(working copy)
@@ -23,7 +23,8 @@
 LIBTOOL_STATIC=libtool -static -o $@ $^
 
 ifdef BUILD_ARCH_universal
-TARGET_ARCH?=-arch i386 -arch ppc -arch x86_64
+#TARGET_ARCH?=-arch i386 -arch ppc -arch x86_64
+TARGET_ARCH?=-arch x86_64 -arch i386 
 endif
 
 ifdef BUILD_ARCH_ppc32
Index: dyncall/buildsys/gmake/tool/gcc.gmake
===================================================================
--- dyncall/buildsys/gmake/tool/gcc.gmake	(revision 1354)
+++ dyncall/buildsys/gmake/tool/gcc.gmake	(working copy)
@@ -86,6 +86,13 @@
 
 #	$(CC) -MM -MT $@ $(CPPFLAGS) $(CFLAGS) $< > $(BUILD_DIR)/$*.d
 
+# --- Compile Objective-C ---------------------------------------------------------------
+
+$(BUILD_DIR)/%.o: %.m
+	$(COMPILE.c) $< $(OUTPUT_OPTION)
+
+#	$(CC) -MM -MT $@ $(CPPFLAGS) $(CFLAGS) $< > $(BUILD_DIR)/$*.d
+
 # --- Compile C++ -------------------------------------------------------------
 
 $(BUILD_DIR)/%.o: %.cpp
